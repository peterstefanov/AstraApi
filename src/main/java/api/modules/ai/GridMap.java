package api.modules.ai;

import java.util.LinkedHashSet;
import java.util.Optional;

import com.google.gson.Gson;

import api.AstraApi;
import api.EventType;
import api.modules.utils.Position;
import api.modules.utils.Rotation;
import api.modules.utils.Scale;
import api.modules.utils.UnityJson;
import astra.core.Module;

public class GridMap extends Module {

	private Gson gson = new Gson();
	//used LinkedHashSet to avoid duplicates and preserve the order
	private static LinkedHashSet<Coordinates> breadCrumbs = new LinkedHashSet<Coordinates>();
	/**Used to distinguish when the end is reached. Passed from Unity*/
	private int endInstanceId = 7777777;

	private PathFinder pathFinder = null;

	/**
	 * The goal of this is to record each move made by the Agent/s, thus a knowledge
	 * map is build which can be used to find the path to the end of the maze.
	 * Position and collisions are recorded, where when collision occurs the blocked
	 * side in the cell is recorded. As this module is designed to be used to reach
	 * the end of a maze, once the maze end is reached its also recorded.
	 * 
	 * @param event
	 * @return the same event
	 */
	@ACTION
	public boolean updateGridMap(String eventType, String event) {
		
		//get current collision/position passed from Unity
		UnityJson requestFromUnity = gson.fromJson(event, UnityJson.class);
        Position position = requestFromUnity.getPosition();
        
        //if instanceId is passed and match the expected one 
        //set the end flag to true, means the end of maze was reached
        int instanceId = requestFromUnity.getInstanceId();
        boolean isEnd = false;
        if (instanceId == endInstanceId) {
        	isEnd = true;
        }
        //which direction is blocked in the cell, only if its a collision event record the data
        String cardinalDirection = eventType.equals(EventType.COLLISION) ? requestFromUnity.getCardinalDirection() : null;

        //store coordinates as integers 
        Coordinates coord = new Coordinates((int) Math.round(position.getX()), (int) Math.round(position.getZ()), cardinalDirection, isEnd);
        breadCrumbs.add(coord);

        return true;
	}
	
	@TERM
	public int getMapSize() {
		return breadCrumbs.size();
	}
	
	/**
	 * Return how many Coordinates instances have finish set to true
	 * @return
	 */
	@TERM
	public int getFinishCount() {
		return (int) breadCrumbs.stream().filter(obj -> obj.isFinish()).count();
	}
	
	@TERM
	public String getBreadCrumbs() {
		return gson.toJson(breadCrumbs);
	}

	/**
	 * Returns the next position coordinates from the list generated by the path finder.
	 * The position contains the precise coordinates from the map.
	 * @param event
	 * @return Json in format:</br>
	 *         {"position":{"x":3.0,"y":0.0,"z":-1.0},"scale":{"x":0.5,"y":1.0,"z":0.5},"rotation":{"x":0.0,"y":0.0,"z":0.0},"type":"position_vector"}
	 */
	@TERM
	public String getNextMove(String event) {
        
		//get current coordinates 
		UnityJson coordinates = gson.fromJson(event, UnityJson.class);

		//initialize the response Object 
		UnityJson responseVector = new UnityJson();	
		api.modules.utils.Position responsePosition = new Position();
		responsePosition.setX(AstraApi.ZERO);
		responsePosition.setY(AstraApi.ZERO);
		responsePosition.setZ(AstraApi.ZERO);
		
		if (pathFinder == null) {
			//Initialize the path finder
			pathFinder = new PathFinder(breadCrumbs, coordinates.getCardinalDirection());
		}
		
		Optional<Coordinates> nextMove = pathFinder.getNextMove();
		
		if (nextMove.isPresent()) {
			Coordinates coord = nextMove.get();
			responsePosition.setX(new Double(coord.getX()));
			responsePosition.setZ(new Double(coord.getY()));
		}
		
		responseVector.setPosition(responsePosition);

		//add Scale to the response json
		Scale coordinatesScale = coordinates.getScale();
		responseVector.setScale(coordinatesScale);
		
		//add Rotation to the response json
		Rotation coordinatesRotation = coordinates.getRotation();
		responseVector.setRotation(coordinatesRotation);

		return gson.toJson(responseVector);
	}
}
